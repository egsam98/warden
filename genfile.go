package warden

import (
	"go/ast"
	"go/token"
	"go/types"
	"os"
	"regexp"
	"strconv"
	"strings"

	"github.com/BurntSushi/toml"
	j "github.com/dave/jennifer/jen"
	"github.com/egsam98/errors"
	"golang.org/x/tools/go/packages"
)

const tomlHeader = "[warden]"

var regexError = regexp.MustCompile(`^Error\s(\d+):\d+`)
var regexVar = regexp.MustCompile(`"id:([\w./]+)"`)

type GenFile struct {
	pkg     string
	statics []*j.Statement
	methods []Method
	f       *j.File
}

type Method struct {
	For   string
	Exprs []*j.Statement
}

func Parse(pkgs []*packages.Package, idx, fileIdx int) error {
	pkg := pkgs[idx]
	f := j.NewFile(pkg.Name)
	file := GenFile{
		pkg: pkg.Name,
		f:   f,
	}

	for _, decl := range pkg.Syntax[fileIdx].Decls {
		decl, ok := decl.(*ast.GenDecl)
		if !ok {
			continue
		}
		if decl.Tok != token.TYPE {
			continue
		}
		spec, ok := decl.Specs[0].(*ast.TypeSpec)
		if !ok {
			continue
		}

		if err := file.parseStruct(pkgs, pkg, spec); err != nil {
			return err
		}
	}

	if len(file.methods) == 0 {
		return nil
	}

	inPath := pkg.CompiledGoFiles[fileIdx]
	outPath := strings.TrimSuffix(inPath, ".go") + "_gen.go"
	out, err := os.OpenFile(outPath, os.O_CREATE|os.O_WRONLY|os.O_TRUNC, 0644)
	if err != nil {
		return errors.Wrap(err, "create output file")
	}
	defer out.Close()

	f.HeaderComment("Code generated by Warden. DO NOT EDIT.")
	for _, staticExpr := range file.statics {
		f.Add(staticExpr)
	}
	for _, method := range file.methods {
		f.Func().
			Params(j.Id("self *" + method.For)).
			Id("Validate").
			Params().
			Error().
			BlockFunc(func(g *j.Group) {
				for _, expr := range method.Exprs {
					g.Add(expr)
				}
				g.Return(j.Nil())
			}).
			Line()
	}

	if err := f.Render(out); err != nil {
		msg := err.Error()
		if sub := regexError.FindStringSubmatch(msg); len(sub) == 2 {
			line, _ := strconv.Atoi(sub[1])
			var i int
			idx := strings.IndexFunc(msg, func(r rune) bool {
				if r == '\n' {
					i++
					if i == line+1 {
						return true
					}
				}
				return false
			})
			return errors.New(msg[:idx] + "\t\t\t<----------" + msg[idx:])
		}
		return err
	}
	return nil
}

func (g *GenFile) parseStruct(pkgs []*packages.Package, pkg *packages.Package, spec *ast.TypeSpec) error {
	structType, ok := spec.Type.(*ast.StructType)
	if !ok {
		return nil
	}

	ctx := Context{StructName: spec.Name.Name, pkgs: pkgs, currPkg: pkg}

	method := Method{For: ctx.StructName}
	for _, field := range structType.Fields.List {
		doc := field.Doc.Text()
		tomlStart := strings.Index(doc, tomlHeader)
		if tomlStart == -1 {
			continue
		}
		doc = doc[tomlStart:]

		if len(field.Names) > 1 {
			return errors.Errorf("multiple field names are unsupported: %v", field.Names)
		}

		field := Field{
			Self:   true,
			Name:   field.Names[0].Name,
			Type:   pkg.TypesInfo.TypeOf(field.Type),
			Object: pkg.TypesInfo.ObjectOf(field.Names[0]),
		}

		var err error
		doc = regexVar.ReplaceAllStringFunc(doc, func(s string) string {
			match := regexVar.FindStringSubmatch(s)[1]
			var obj types.Object
			if obj, err = ctx.FindObject(match); err != nil {
				return ""
			}
			switch obj := obj.(type) {
			case *types.Const:
				return obj.Val().String()
			default:
				err = errors.Errorf("resole variable: %s is not const", s)
				return ""
			}
		})
		if err != nil {
			return err
		}

		var ruleDefs struct {
			Warden map[string]Properties `toml:"warden"`
			Each   map[string]Properties `toml:"each"`
		}
		if _, err := toml.Decode(doc, &ruleDefs); err != nil {
			return errors.Wrapf(err, "decode rule definitions for field %s.%s", ctx.StructName, field.Name)
		}
		exprs, err := g.parseRuleDefs(&ctx, field, ruleDefs.Warden)
		if err != nil {
			return err
		}
		method.Exprs = append(method.Exprs, exprs...)

		if len(ruleDefs.Each) > 0 {
			innerType, err := innerTypeOfIterable(field.Type)
			if err != nil {
				return err
			}

			eachField := Field{Name: "elem", Type: innerType}
			eachExprs, err := g.parseRuleDefs(&ctx, eachField, ruleDefs.Each)
			if err != nil {
				return err
			}

			loopExpr := j.For().Id("_, elem").Op(":=").Range().Add(field.Jen()).BlockFunc(func(gr *j.Group) {
				for _, expr := range eachExprs {
					gr.Add(expr)
				}
			})
			method.Exprs = append(method.Exprs, loopExpr)
		}
	}

	if len(method.Exprs) > 0 {
		g.methods = append(g.methods, method)
	}
	return nil
}

func (g *GenFile) parseRuleDefs(ctx *Context, field Field, def map[string]Properties) ([]*j.Statement, error) {
	var exprs []*j.Statement
	for key, props := range def {
		rule, err := Get(key)
		if err != nil {
			return nil, err
		}

		expr, static, err := rule.Render(ctx, field, props)
		if err != nil {
			return nil, errors.Wrapf(err, "%s.%s: %s", ctx.StructName, field.Name, key)
		}

		exprs = append(exprs, expr)
		if static != nil {
			g.statics = append(g.statics, static)
		}
	}
	return exprs, nil
}

func innerTypeOfIterable(typ types.Type) (types.Type, error) {
	switch typ := typ.(type) {
	case *types.Named, *types.Alias:
		return innerTypeOfIterable(typ.Underlying())
	case *types.Slice:
		return typ.Elem(), nil
	case *types.Array:
		return typ.Elem(), nil
	case *types.Map:
		return typ.Elem(), nil
	default:
		return nil, errors.Errorf("%T is not iterable (cannot apply `range` func)", typ)
	}
}
