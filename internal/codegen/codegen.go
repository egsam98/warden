package codegen

import (
	"bytes"
	"fmt"
	"go/ast"
	"go/token"
	"go/types"
	"io"
	"log"
	"os"
	"regexp"
	"slices"
	"strconv"
	"strings"

	j "github.com/dave/jennifer/jen"
	"github.com/egsam98/errors"
	"golang.org/x/tools/go/packages"

	"github.com/egsam98/warden/internal/omap"
)

const mod = "github.com/egsam98/warden"
const tomlHeader = "warden"
const genSuffix = "_gen.go"
const maxDepth = 3

var regexError = regexp.MustCompile(`^Error\s(\d+):\d+`)
var regexVar = regexp.MustCompile(`id:([\w./]+)`)

type NamedOrAlias interface {
	types.Type
	Obj() *types.TypeName
}

func Gen(pkgs []*packages.Package, tag *string, depth ...int) error {
	if len(pkgs) == 0 {
		return errors.New("no packages found")
	}

	for _, pkg := range pkgs {
		var errs []string
		for _, err := range pkg.Errors {
			if strings.Contains(err.Pos, genSuffix) {
				continue
			}
			errs = append(errs, err.Error())
		}
		if len(errs) > 0 {
			return errors.New(strings.Join(errs, "; "))
		}
	}

	for _, pkg := range pkgs {
		_depth := 0
		if len(depth) > 0 {
			_depth = depth[0]
		}

		if _depth == 0 {
			log.Printf("Scanning package %s and its imports", pkg.Name)
		}

		if _depth < maxDepth {
			var importPkgs []*packages.Package
			for _, pkg := range pkg.Imports {
				if types.Universe.Lookup(pkg.PkgPath) != nil {
					fmt.Println("SKIP", pkg.PkgPath)
					continue
				}
				importPkgs = append(importPkgs, pkg)
			}
			if len(importPkgs) > 0 {
				if err := Gen(importPkgs, tag, _depth+1); err != nil {
					return err
				}
			}
		}

		for i, file := range pkg.Syntax {
			path := pkg.CompiledGoFiles[i]
			if strings.HasSuffix(path, genSuffix) {
				continue
			}
			if err := genFile(pkgs, tag, pkg, path, file); err != nil {
				return err
			}
		}
	}
	return nil
}

type method struct {
	For   string
	Exprs []*j.Statement
}

func genFile(pkgs []*packages.Package, tag *string, pkg *packages.Package, path string, file *ast.File) error {
	gen := j.NewFile(pkg.Name)

	var methods []method
	var staticExprs []*j.Statement
	for _, decl := range file.Decls {
		decl, ok := decl.(*ast.GenDecl)
		if !ok {
			continue
		}
		if decl.Tok != token.TYPE {
			continue
		}
		spec, ok := decl.Specs[0].(*ast.TypeSpec)
		if !ok {
			continue
		}
		structType, ok := spec.Type.(*ast.StructType)
		if !ok {
			continue
		}

		ctx := Context{StructName: spec.Name.Name, pkg: pkg, pkgs: pkgs, tag: tag}
		exprs, err := genStruct(&ctx, structType)
		if err != nil {
			return errors.Wrap(err, "%s.%s", pkg.PkgPath, ctx.StructName)
		}
		if len(exprs) == 0 {
			continue
		}
		methods = append(methods, method{For: spec.Name.Name, Exprs: exprs})
		staticExprs = append(staticExprs, ctx.statics...)
	}

	if len(methods) == 0 {
		return nil
	}

	gen.HeaderComment("Code generated by Warden. DO NOT EDIT.")
	for _, staticExpr := range staticExprs {
		gen.Add(staticExpr)
	}
	for _, method := range methods {
		gen.Func().
			Params(j.Id("self *" + method.For)).
			Id("Validate").
			Params().
			Error().
			BlockFunc(func(g *j.Group) {
				g.Var().Id("errs").Qual(mod, "Errors")
				for _, expr := range method.Exprs {
					g.Add(expr)
				}
				g.Return(j.Id("errs").Dot("AsError").Call())
			}).
			Line()
	}

	var out bytes.Buffer
	if err := gen.Render(&out); err != nil {
		msg := err.Error()
		if sub := regexError.FindStringSubmatch(msg); len(sub) == 2 {
			line, _ := strconv.Atoi(sub[1])
			var i int
			idx := strings.IndexFunc(msg, func(r rune) bool {
				if r == '\n' {
					i++
					if i == line+1 {
						return true
					}
				}
				return false
			})
			return errors.New(msg[:idx] + "\t\t\t<----------" + msg[idx:])
		}
		return err
	}

	outFile, err := os.OpenFile(
		strings.TrimSuffix(path, ".go")+genSuffix,
		os.O_CREATE|os.O_WRONLY|os.O_TRUNC,
		0644,
	)
	if err != nil {
		return errors.Wrap(err, "create output file")
	}
	defer outFile.Close()
	_, err = io.Copy(outFile, &out)
	return err
}

func genStruct(ctx *Context, structType *ast.StructType) ([]*j.Statement, error) {
	var exprs []*j.Statement
	for _, field := range structType.Fields.List {
		if field.Doc == nil {
			continue
		}
		tomlStart := slices.IndexFunc(field.Doc.List, func(comm *ast.Comment) bool {
			return strings.Trim(comm.Text, `/ `) == "["+tomlHeader+"]"
		})
		if tomlStart == -1 {
			continue
		}
		if len(field.Names) > 1 {
			return nil, errors.Errorf("multiple field names are unsupported: %v", field.Names)
		}

		cfg, err := omap.Decode(field.Doc.Text())
		if err != nil {
			return nil, err
		}
		warden, ok := cfg.Get(tomlHeader)
		if !ok {
			return nil, errors.Errorf("main toml key %s isn't found", tomlHeader)
		}
		cfg = warden.(*omap.OrderedMap[any])

		name := field.Names[0].Name
		if ctx.tag != nil && field.Tag != nil {
			regexTag, err := regexp.Compile(*ctx.tag + `:"([^,"]+)["|,]`)
			if err != nil {
				return nil, errors.Wrap(err, "build regex for struct tag")
			}
			if match := regexTag.FindStringSubmatch(field.Tag.Value); len(match) == 2 && match[1] != "-" {
				name = match[1]
			}
		}

		field := Field{
			Self: true,
			ID:   field.Names[0].Name,
			Name: j.Lit(name),
			Type: ctx.pkg.TypesInfo.TypeOf(field.Type),
			Expr: field.Type,
		}
		for key, value := range cfg.Range() {
			expr, err := genRules(ctx, field, key, value)
			if err != nil {
				return nil, err
			}
			exprs = append(exprs, expr)
		}
	}
	return exprs, nil
}

func genRules(ctx *Context, field Field, ruleName string, value any) (*j.Statement, error) {
	rule, ok := rules[ruleName]
	if !ok {
		return nil, errors.Errorf("unknown rule: %q", ruleName)
	}
	var props Properties
	if err := props.parse(ctx, value); err != nil {
		return nil, err
	}
	expr, err := rule.Render(ctx, field, props)
	return expr, errors.Wrap(err, "field %s: %s", field.Name.GoString(), ruleName)
}

type Context struct {
	StructName string
	pkg        *packages.Package
	pkgs       []*packages.Package
	tag        *string
	statics    []*j.Statement
}

func (c *Context) addStatic(stmt *j.Statement) {
	c.statics = append(c.statics, stmt)
}

func (c *Context) findObject(rawIdent string) (types.Object, error) {
	var path, ident string
	if dotIdx := strings.LastIndexByte(rawIdent, '.'); dotIdx == -1 {
		ident, path = rawIdent, c.pkg.PkgPath
	} else {
		path, ident = rawIdent[:dotIdx], rawIdent[dotIdx+1:]
	}

	for _, pkg := range c.pkgs {
		pkg = func(pkg *packages.Package) *packages.Package {
			if pkg.PkgPath == path {
				return pkg
			}
			for importPath, pkg := range pkg.Imports {
				if importPath == path {
					return pkg
				}
			}
			return nil
		}(pkg)
		if pkg == nil {
			continue
		}

		obj := pkg.Types.Scope().Lookup(ident)
		if obj == nil {
			break
		}
		return obj, nil
	}

	return nil, errors.Errorf("identifier %s.%s not found", path, ident)
}

type Field struct {
	Self, Deref bool
	ID          string
	Name        *j.Statement
	Type        types.Type
	Expr        ast.Expr
}

func (f *Field) gen(deref ...bool) *j.Statement {
	_deref := true
	if len(deref) > 0 {
		_deref = deref[0]
	}

	var id *j.Statement
	if f.Self {
		id = j.Id("self." + f.ID)
	} else {
		id = j.Id(f.ID)
	}
	if f.Deref && _deref {
		return j.Op("*").Add(id)
	}
	return id
}

func (f *Field) genString() *j.Statement {
	fieldType := f.Type
	var named bool
	for {
		switch typ := fieldType.(type) {
		case *types.Alias:
			fieldType = typ.Underlying()
		case *types.Named:
			if implements(typ, ifaceStringer) {
				return f.gen(false).Dot(ifaceStringer.Method(0).Name()).Call()
			}
			named = true
			fieldType = typ.Underlying()
		default:
			stmt := f.gen()
			if named {
				stmt = j.Id("string").Parens(stmt)
			}
			return stmt
		}
	}
}
