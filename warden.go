package warden

import (
	"go/ast"
	"go/token"
	"go/types"
	"os"
	"regexp"
	"strconv"
	"strings"

	"github.com/BurntSushi/toml"
	j "github.com/dave/jennifer/jen"
	"github.com/egsam98/errors"
	"golang.org/x/tools/go/packages"
)

const tomlHeader = "[warden]"
const genSuffix = "_gen.go"

var regexError = regexp.MustCompile(`^Error\s(\d+):\d+`)
var regexVar = regexp.MustCompile(`id:([\w./]+)`)

type namedOrAlias interface {
	types.Type
	Obj() *types.TypeName
}

func Parse(pkgs []*packages.Package) error {
	if len(pkgs) == 0 {
		return errors.New("no packages found")
	}

	for _, pkg := range pkgs {
		var errs []string
		for _, err := range pkg.Errors {
			if strings.Contains(err.Pos, genSuffix) {
				continue
			}
			errs = append(errs, err.Error())
		}
		if len(errs) > 0 {
			return errors.New(strings.Join(errs, "; "))
		}
	}

	for _, pkg := range pkgs {
		for i, file := range pkg.Syntax {
			path := pkg.CompiledGoFiles[i]
			if strings.HasSuffix(path, genSuffix) {
				continue
			}
			if err := parseFile(pkgs, pkg, path, file); err != nil {
				return err
			}
		}
	}
	return nil
}

type method struct {
	For   string
	Exprs []*j.Statement
}

func parseFile(pkgs []*packages.Package, pkg *packages.Package, path string, file *ast.File) error {
	gen := j.NewFile(pkg.Name)

	var methods []method
	var staticExprs []*j.Statement
	for _, decl := range file.Decls {
		decl, ok := decl.(*ast.GenDecl)
		if !ok {
			continue
		}
		if decl.Tok != token.TYPE {
			continue
		}
		spec, ok := decl.Specs[0].(*ast.TypeSpec)
		if !ok {
			continue
		}
		structType, ok := spec.Type.(*ast.StructType)
		if !ok {
			continue
		}

		ctx := Context{StructName: spec.Name.Name, Pkg: pkg, pkgs: pkgs}
		method := method{For: spec.Name.Name}
		if err := parseStruct(&ctx, &method, structType); err != nil {
			return err
		}
		if len(method.Exprs) == 0 {
			continue
		}
		methods = append(methods, method)
		staticExprs = append(staticExprs, ctx.statics...)
	}

	if len(methods) == 0 {
		return nil
	}

	out, err := os.OpenFile(
		strings.TrimSuffix(path, ".go")+genSuffix,
		os.O_CREATE|os.O_WRONLY|os.O_TRUNC,
		0644,
	)
	if err != nil {
		return errors.Wrap(err, "create output file")
	}
	defer out.Close()

	gen.HeaderComment("Code generated by Warden. DO NOT EDIT.")
	for _, staticExpr := range staticExprs {
		gen.Add(staticExpr)
	}
	for _, method := range methods {
		gen.Func().
			Params(j.Id("self *" + method.For)).
			Id("Validate").
			Params().
			Error().
			BlockFunc(func(g *j.Group) {
				for _, expr := range method.Exprs {
					g.Add(expr)
				}
				g.Return(j.Nil())
			}).
			Line()
	}

	if err := gen.Render(out); err != nil {
		msg := err.Error()
		if sub := regexError.FindStringSubmatch(msg); len(sub) == 2 {
			line, _ := strconv.Atoi(sub[1])
			var i int
			idx := strings.IndexFunc(msg, func(r rune) bool {
				if r == '\n' {
					i++
					if i == line+1 {
						return true
					}
				}
				return false
			})
			return errors.New(msg[:idx] + "\t\t\t<----------" + msg[idx:])
		}
		return err
	}
	return nil
}

func parseStruct(ctx *Context, method *method, structType *ast.StructType) error {
	for _, field := range structType.Fields.List {
		doc := field.Doc.Text()
		tomlStart := strings.Index(doc, tomlHeader)
		if tomlStart == -1 {
			continue
		}
		doc = doc[tomlStart:]

		if len(field.Names) > 1 {
			return errors.Errorf("multiple field names are unsupported: %v", field.Names)
		}

		field := Field{
			Self: true,
			Name: field.Names[0].Name,
			Type: ctx.Pkg.TypesInfo.TypeOf(field.Type),
		}

		var defs struct {
			Warden map[string]any `toml:"warden"`
			Each   map[string]any `toml:"each"`
		}
		if _, err := toml.Decode(doc, &defs); err != nil {
			return errors.Wrap(err, "decode rule definitions for field %s.%s", ctx.StructName, field.Name)
		}

		exprs, err := genRules(ctx, field, defs.Warden)
		if err != nil {
			return err
		}
		method.Exprs = append(method.Exprs, exprs...)

		if len(defs.Each) > 0 {
			eachField := Field{
				Self:  false,
				Deref: false,
				Name:  "elem",
				Type:  innerTypeOfIterable(field.Type),
			}

			eachExprs, err := genRules(ctx, eachField, defs.Each)
			if err != nil {
				return err
			}

			loopExpr := j.For().Id("_, elem").Op(":=").Range().Add(field.Gen()).BlockFunc(func(gr *j.Group) {
				for _, expr := range eachExprs {
					gr.Add(expr)
				}
			})
			method.Exprs = append(method.Exprs, loopExpr)
		}
	}
	return nil
}

func genRules(ctx *Context, field Field, ruleDefs map[string]any) ([]*j.Statement, error) {
	var exprs []*j.Statement
	for ruleName, v := range ruleDefs {
		rule, ok := rules[ruleName]
		if !ok {
			return nil, errors.Errorf("unknown rule: %q", ruleName)
		}

		var props Properties
		if err := props.parse(ctx, v); err != nil {
			return nil, err
		}

		expr, err := rule.Render(ctx, field, props)
		if err != nil {
			return nil, errors.Wrap(err, "%s.%s: %s", ctx.StructName, field.Name, ruleName)
		}

		exprs = append(exprs, expr)
	}
	return exprs, nil
}

type Field struct {
	Self, Deref bool
	Name        string
	Type        types.Type
}

func (f *Field) Gen(deref ...bool) *j.Statement {
	_deref := true
	if len(deref) > 0 {
		_deref = deref[0]
	}

	var id *j.Statement
	if f.Self {
		id = j.Id("self." + f.Name)
	} else {
		id = j.Id(f.Name)
	}
	if f.Deref && _deref {
		return j.Op("*").Add(id)
	}
	return id
}

func (f *Field) GenString() *j.Statement {
	fieldType := f.Type
	var named bool
	for {
		switch typ := fieldType.(type) {
		case *types.Alias:
			fieldType = typ.Underlying()
		case *types.Named:
			if Implements(typ, ifaceStringer) {
				return f.Gen(false).Dot(ifaceStringer.Method(0).Name()).Call()
			}
			named = true
			fieldType = typ.Underlying()
		default:
			stmt := f.Gen()
			if named {
				stmt = j.Id("string").Parens(stmt)
			}
			return stmt
		}
	}
}

func innerTypeOfIterable(typ types.Type) types.Type {
	switch typ := typ.(type) {
	case *types.Named, *types.Alias:
		return innerTypeOfIterable(typ.Underlying())
	case *types.Slice:
		return typ.Elem()
	case *types.Array:
		return typ.Elem()
	case *types.Map:
		return typ.Elem()
	default:
		panic(errors.Errorf("%T is not iterable (cannot apply `range` func)", typ))
	}
}
